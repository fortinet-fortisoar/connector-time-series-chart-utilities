from connectors.core.connector import get_logger, ConnectorError
from .constants import LOGGER_NAME
import arrow
logger = get_logger(LOGGER_NAME)

def assemble_query_time_windows(config, params):
    # This function is used to take a relative date (last x months, for example) and a time period (daily, monthly, etc)
    #  It will generate a list of timestamps starting from the relative date and extending to the present by an interval specified
    #  by the time window. Optionally, a list of datetimes can be passed in to represent a list of times generated by a previous
    #  execution of this function. In that case, the generated timestamps will follow the specifieid interval from the latest
    #  time in that list, rather than from the current time.
    #  For example, if you passed in a list of 1:00, 2:00, 3:00 with time period hourly, then even if this executed at 4:15,
    #  the next item added to the list would be 4:00, because it would be one hour after the last time in the passed-in list.
    relative_date = params.get('relativeDate')
    period = params.get('time_period')
    date_format = params.get('dateFormat', 'YYYY-MM-DDTHH:mm:ss.SSS[Z]')
    existing_times = params.get('existing_times', [])
    query_modified = params.get('query_modified', False)

    start_time, end_time = _handleRelativeDate(relative_date, period)

    if existing_times and not query_modified:
        # Find the index of the first time in the exiting time stamps which is >= to the calculated start time
        first_bucket_index = 0
        column_heading_present = False
        try:
            # Check the first element of the existing times list
            arrow.get(existing_times[first_bucket_index])
        except arrow.parser.ParserError:
            # If the first element of that list is not a datetime, then
            #  it is probably a string, since the c3  column format allows
            #  for the dataset header to appear as the first element in the list
            #  In this case, move to the second element and try again
            first_bucket_index = 1
            column_heading_present = True
        try:
            while arrow.get(existing_times[first_bucket_index]) < start_time:
                first_bucket_index += 1
        except arrow.parser.ParserError as e:
            # If this parserError hits it means that neither the first nor
            #  second element in the existing data list was arrow parsable. 
            #  In this case raise an error.
            logger.error("Arrow library could not parse the object {}".format(existing_times[first_bucket_index]))
            raise ConnectorError("Arrow library could not parse the object {}".format(existing_times[first_bucket_index]))
        
        # Strip out all times less than the calculated start time
        existing_times = existing_times[first_bucket_index:]
        first_record_to_keep_index = first_bucket_index if column_heading_present else first_bucket_index + 1

        # We will always re-query the last time window from the existing chart
        # because it likely represents an incomplete time window. After that, keep applying the 
        # time period shift until a timestamp is found which is after the "end time" of the chart
        last_timebucket = existing_times[-1]
        time_buckets_to_query = [{'start': last_timebucket}]
        last_timebucket = arrow.get(last_timebucket)
        if last_timebucket < end_time:
            time_buckets_to_query[0]['end'] = _shift_time(last_timebucket,  period).format(date_format)
        while arrow.get(time_buckets_to_query[-1]['end']) < end_time:
            new_bucket = {'start': time_buckets_to_query[-1]['end']}
            new_endtime = _shift_time(arrow.get(time_buckets_to_query[-1]['end']), period)
            new_bucket['end'] = new_endtime.format(date_format) if new_endtime < end_time else end_time.format(date_format)
            time_buckets_to_query.append(new_bucket)
        return {"query_buckets": time_buckets_to_query, "mode": "update_buckets", "first_index_to_keep": first_record_to_keep_index}
    else:
        # When no existing data is present, we just take the start time and apply
        # the time period shift until a timestamp is reached which is past the 
        # chart's end time
        time_buckets = []
        time_slider = start_time
        while time_slider < end_time:
            new_bucket = {'start': time_slider.format(date_format)}
            time_slider = _shift_time(time_slider, period)
            new_bucket['end'] = time_slider.format(date_format) if time_slider < end_time else end_time.format(date_format)
            time_buckets.append(new_bucket)
        return {'query_buckets': time_buckets, 'mode': 'new_chart', 'first_index_to_keep': None}
  
def _shift_time(time_value, period):
    new_t = time_value
    if period=="Hourly":
        new_t = time_value.shift(hours=1)
    elif period=="Daily":
        new_t = time_value.shift(days=1)
    elif period == "Weekly":
        new_t = time_value.shift(weeks=1)
    elif period == "Montly":
        new_t = time_value.shift(months=1)
    elif period == "Quarterly":
        new_t = time_value.shift(months=3)
    elif period == "Yearly":
        new_t = time_value.shift(years=1)
    return new_t

def _handleRelativeDate(relDate, period):
    playbookStartTime = arrow.get().replace(second=0, microsecond=0)
    if "differenceType" in relDate:
        differenceValue = relDate['differenceValue']
        differenceType = relDate['differenceType']
        startDate = playbookStartTime
        endDate = playbookStartTime
        if differenceType == 'mins':
            differenceType = 'minutes'
        if differenceValue < 0:
            # start date is going to be shifted back by differenceValue units, end date is now
            startDate = endDate.shift(**{differenceType: differenceValue})
        elif differenceValue == 0:
            # "this" date. start date will be the start of this unit, end date is now
            if differenceType == 'minutes':
                startDate = endDate.replace(second=0,microsecond=0)
            if differenceType == 'hours':
                startDate = endDate.replace(minute=0, second=0,microsecond=0)
            elif differenceType == "days":
                startDate = endDate.replace(hour=0,minute=0,second=0,microsecond=0)
            elif differenceType == "months":
                startDate = endDate.replace(day=1, hour=0,minute=0,second=0,microsecond=0)
            elif differenceType == 'years':
                startDate = endDate.replace(month=1, day=1, hour=0,minute=0,second=0,microsecond=0)
        elif differenceValue > 0:
            #future date. Start date is now, end date is shifted forward by differenceValue uniits
            endDate = startDate.shift(**{differenceType: differenceValue})
        return startDate, endDate